<html>
    <head>
        <meta charset="utf-8">
        <title>Trabalho Final Grafos - UFSCar 2017/1</title>

        <!-- Bootstrap Core CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">

        <!-- Template Custom Fonts -->
        <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Clean Blog CSS -->
        <link href="pages/css/clean-blog.css" rel="stylesheet" type="text/css">

        <!-- Highlight JS -->
        <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    </head>

    <body>
        <!-- Page Header -->
        <header class="masthead" style="background-image: url('pages/img/header.jpg')">
            <div class="overlay"></div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-md-10 mx-auto">
                        <div class="site-heading">
                            <h1>Grafos</h1>
                            <span class="subheading">Universidade Federal de São Carlos</span>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Page Content -->        
        <article>
            <div class="container">
                <div class="row">
                    <div class="col-lg-11 col-md-11 mx-auto">
                        <!-- Introduction -->
                        <p>Esse site é um agregado de pequenos tutoriais para a disciplina de Teoria dos Grafos, do segundo semestre do ano de 2017, ministrada pelo Prof. Dr. Alexandre Levada. Os alunos integrantes desse grupo são:</p>
                        <ul>
                            <li>Gabriel de Souza Alves      726515</li>
                            <li>Matheus Bortoleto da Silva  726570</li>
			    <li>Jéssica Gama Simões	    511323</li>
                        </ul>
                        <p>Os tópicos que esse trabalho busca abordar são:</p>
                        <ul>
                            <li><a href="#markov">Cadeia de Markov</a></li>
                            <li><a href="#prim">Algoritmo de Prim</a></li>
                            <li><a href="#bfsdfs">BFS e DFS</a></li>
                            <li><a href="#dijkstra">Algoritmo de Dijkstra</a></li>
			    <li><a href="#tsp">Problema do Caixeiro Viajante</a></li>
                        </ul>

                        <!-- Markov Chain -->
                        <h1 id="markov" class="section-heading">Cadeia de Markov</h1>
						<h2 id="snakes-and-ladders">Snakes and Ladders</h2>
						<p>Snakes and Ladders é um famoso jogo de tabuleiro em que a cada rodada um jogador joga uma moeda não viciada e avança 1 casa se obtiver cara ou avança 2 casas se obtiver coroa. Se o jogador para no pé da escada, então ele imediatamente sobe para o topo da escada. Se o jogador cai na boca de um cobra então ele imediatamente escorrega para o rabo. O jogador sempre inicia no quadrado de número 1. O jogo termina quando ele atinge o quadrado de número 36.</p>
						<h2 id="método">Método</h2>
						<p>Para o problema do Snakes and Ladders fizemos a implementação em Python das casas onde havia uma cobra ou uma escada na função shift(), que indica para onde deve ir o jogador que pare em uma delas:</p>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">def</span> shift_positions():</a>
						<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="co"># Builds the game table with the shift positions for the Snakes and Ladders squares</span></a>
						<a class="sourceLine" id="cb1-3" data-line-number="3">    table <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">36</span>)]</a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    table[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">14</span></a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    table[<span class="dv">4</span>] <span class="op">=</span> <span class="dv">6</span></a>
						<a class="sourceLine" id="cb1-6" data-line-number="6">    table[<span class="dv">8</span>] <span class="op">=</span> <span class="dv">26</span></a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">    table[<span class="dv">16</span>] <span class="op">=</span> <span class="dv">3</span></a>
						<a class="sourceLine" id="cb1-8" data-line-number="8">    table[<span class="dv">17</span>] <span class="op">=</span> <span class="dv">28</span></a>
						<a class="sourceLine" id="cb1-9" data-line-number="9">    table[<span class="dv">19</span>] <span class="op">=</span> <span class="dv">5</span></a>
						<a class="sourceLine" id="cb1-10" data-line-number="10">    table[<span class="dv">23</span>] <span class="op">=</span> <span class="dv">15</span></a>
						<a class="sourceLine" id="cb1-11" data-line-number="11">    table[<span class="dv">24</span>] <span class="op">=</span> <span class="dv">34</span></a>
						<a class="sourceLine" id="cb1-12" data-line-number="12">    table[<span class="dv">31</span>] <span class="op">=</span> <span class="dv">29</span></a>
						<a class="sourceLine" id="cb1-13" data-line-number="13">    table[<span class="dv">33</span>] <span class="op">=</span> <span class="dv">11</span></a>
						<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="cf">return</span> table</a></code></pre></div>
						<p>E implementamos também funções para calcular a cadeia de Markov e o Power Method:</p>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">def</span> markov_chain(shift):</a>
						<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="co"># Builds the Markov Chain for the table which indicates the probability of reaching a table square from another</span></a>
						<a class="sourceLine" id="cb1-3" data-line-number="3">    chain <span class="op">=</span> np.zeros(shape<span class="op">=</span>(<span class="dv">36</span>,<span class="dv">36</span>))</a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(chain)):</a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">        <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(chain[x])):</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6">            <span class="cf">if</span> (x<span class="op">+</span><span class="dv">1</span>) <span class="op">&lt;</span> <span class="dv">36</span> <span class="kw">and</span> y <span class="op">&gt;</span> x:</a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">                <span class="cf">if</span> shift[x<span class="op">+</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>:</a>
						<a class="sourceLine" id="cb1-8" data-line-number="8">                    chain[x][x<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="fl">0.5</span></a>
						<a class="sourceLine" id="cb1-9" data-line-number="9">                <span class="cf">else</span>:</a>
						<a class="sourceLine" id="cb1-10" data-line-number="10">                    chain[x][shift[x<span class="op">+</span><span class="dv">1</span>]] <span class="op">=</span> <span class="fl">0.5</span></a>
						<a class="sourceLine" id="cb1-11" data-line-number="11">            <span class="cf">if</span> (x<span class="op">+</span><span class="dv">2</span>) <span class="op">&lt;</span> <span class="dv">36</span> <span class="kw">and</span> y <span class="op">&gt;</span> x:</a>
						<a class="sourceLine" id="cb1-12" data-line-number="12">                <span class="cf">if</span> shift[x<span class="op">+</span><span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>:</a>
						<a class="sourceLine" id="cb1-13" data-line-number="13">                    chain[x][x<span class="op">+</span><span class="dv">2</span>] <span class="op">=</span> <span class="fl">0.5</span></a>
						<a class="sourceLine" id="cb1-14" data-line-number="14">                <span class="cf">else</span>:</a>
						<a class="sourceLine" id="cb1-15" data-line-number="15">                    chain[x][shift[x<span class="op">+</span><span class="dv">2</span>]] <span class="op">=</span> <span class="fl">0.5</span></a>
						<a class="sourceLine" id="cb1-16" data-line-number="16">    <span class="cf">return</span> chain</a>
						<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
						<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">def</span> power_method(markov, times):</a>
						<a class="sourceLine" id="cb1-19" data-line-number="19">    A <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">36</span>)]</a>
						<a class="sourceLine" id="cb1-20" data-line-number="20">    A[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></a>
						<a class="sourceLine" id="cb1-21" data-line-number="21"></a>
						<a class="sourceLine" id="cb1-22" data-line-number="22">    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(times):</a>
						<a class="sourceLine" id="cb1-23" data-line-number="23">        pos <span class="op">=</span> []</a>
						<a class="sourceLine" id="cb1-24" data-line-number="24">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">36</span>):</a>
						<a class="sourceLine" id="cb1-25" data-line-number="25">            pos.append(<span class="dv">0</span>)</a>
						<a class="sourceLine" id="cb1-26" data-line-number="26">            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">36</span>):</a>
						<a class="sourceLine" id="cb1-27" data-line-number="27">                pos[i] <span class="op">+=</span> A[j]<span class="op">*</span>markov[j][i]</a>
						<a class="sourceLine" id="cb1-28" data-line-number="28">        A <span class="op">=</span> pos</a>
						<a class="sourceLine" id="cb1-29" data-line-number="29">    <span class="cf">return</span> A</a></code></pre></div>
						<h2 id="a">A)</h2>
						<p>Para poder obter o diagrama de estados da cadeia de Markov, rodamos o script que fizemos e este foi o resultado:</p>
						
						<img src="pages/img/markov.jpeg" alt="Cadeia de Markov resultante" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

						<h2 id="b">B)</h2>
						<p>Para calcular a distribuição estacionária da cadeia de Markov, rodamos nosso script de Power method 100 vezes, passando a cadeia e o número de vezes desejado na função <code>power_method(M,100)</code></p>
						<p>O resultado para cada posição do tabuleiro foi este:</p>
						<a href="pages/data/power_method.txt">Resultado</a>
						<p>É possível ver que para a última posição do tabuleiro (#36) a chance de chegar (e vencer) a longo prazo é de 0.04101%.</p>
						<p>Podemos também ver que as posições mais acessadas são #29, #16 e #4, sendo a posição #29 a mais acessada de todas.</p>

                        <hr>

                        <!-- Prim -->
                        <h1 id="prim" class="section-heading">Algoritmo de Prim</h1>
                        <p>O algoritmo de Prim é um dos mais utilizados para encontrar árvores mínimas geradoras, ou MSTs, dado um determinado grafo. Nesse tutorial, iremos criar passo à passo uma função que nos retorna uma MST, utilizando Prim.</p>
						<p>Inicialmente, criamos uma função chamada prim, que recebe um objeto do tipo <code>networkx.Graph</code>. Esse é o grafo que será utilizado para encontrar a árvore mínima geradora. Também iremos adicionar um novo objeto na função, chamado de <code>mst</code>, que será retornado no final da execução. Essa será a árvore resultante.</p>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Prim. Recebe um nx.Graph e retorna um nx.DiGraph</span></a>
						<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">def</span> prim(graph):</a>
						<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="co"># Digrafo resultante</span></a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    mst <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="cf">return</span> mst</a></code></pre></div>
						<p>O passo seguinte é adicionar as propriedades de <em>cor (branco se não visitado, preto se foi), lambda (distância mínima encontrada) e pi (pai do vértice)</em>. Para isso, podemos utilizar os atributos das vértices do próprio grafo recebido pela função. Inicializamos então todos os vértices com a cor branca, todos eles sem pai e todos menos o vértice inicial com a lambda infinito. O lambda do vértice inicial deve receber 0, para que o algoritmo tenha um vértice para começar.</p>
						<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># Inicializa as cores dos vértices como branco</span></a>
						<a class="sourceLine" id="cb2-2" data-line-number="2">nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
						<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co"># Inicializa o pi(pai) dos vértices como None</span></a>
						<a class="sourceLine" id="cb2-5" data-line-number="5">nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
						<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co"># Inicializa o lambda(distância mínima) dos vértices como infinito</span></a>
						<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co"># O vértice inicial recebe 0</span></a>
						<a class="sourceLine" id="cb2-9" data-line-number="9">nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="cf">for</span> node <span class="kw">in</span> graph.nodes:</a>
						<a class="sourceLine" id="cb2-11" data-line-number="11">    nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="cf">break</span>   <span class="co"># Executa o loop para apenas um nó</span></a></code></pre></div>
						<p>Em seguida, iremos criar o loop principal, que será executado enquanto existirem vértices com a cor branca (não visitados). Ele deverá selecionar o vértice com menor lambda. Para isso, fazemos o seguinte:</p>
						<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Enquanto existir um vértice não visitado, continua visitando</span></a>
						<a class="sourceLine" id="cb3-2" data-line-number="2">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>) <span class="co"># nos dá todos os vértices do grafo, junto com seus atributos</span></a>
						<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
						<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="co"># Seleciona apenas os vértices brancos</span></a>
						<a class="sourceLine" id="cb3-5" data-line-number="5">    white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
						<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="co"># Seleciona o vértice com menor lambda</span></a>
						<a class="sourceLine" id="cb3-7" data-line-number="7">    min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>])</a></code></pre></div>
						<p>Com o loop principal iniciado, só nós resta adicionar a visita dos vértices vizinhos ao vértice atual. Para isso, utilizamos outros loop, que itera sobre todos os vértices vizinhos, checando se a nova distância é menor que o lambda armazenado. Se for, os valores de lambda e pi são atualizados. Ao final desse loop, só nos resta atualizar a cor do vértice que visitamos nessa iteração e atualizar a lista de nós.</p>
						<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># Itera sobre todos os vizinhos do vértice, e atualiza os atributos se necessário</span></a>
						<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
						<a class="sourceLine" id="cb4-3" data-line-number="3">    node_info <span class="op">=</span> (node, <span class="bu">dict</span>(nodes_info)[node])</a>
						<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb4-5" data-line-number="5">        new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>]</a>
						<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="co"># Checa se é necessário atualizar os atributos</span></a>
						<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
						<a class="sourceLine" id="cb4-8" data-line-number="8">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb4-9" data-line-number="9">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb4-10" data-line-number="10">nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb4-11" data-line-number="11">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
						<p>Assim que o algoritmo é finalizado, e todos os vértices recebem um pai, assim como um lambda representando a distância mínima, o único passo restante é montar a árvore com os dados. Devemos então, iterar sobre todos os nós, adicionando arestas utilizando o valor do nó, o valor de pi como pai e o valor de lambda como peso.</p>
						<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># Adiciona os nós à mst</span></a>
						<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
						<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
						<a class="sourceLine" id="cb5-4" data-line-number="4">        edge_weight <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
						<a class="sourceLine" id="cb5-5" data-line-number="5">        parent <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
						<a class="sourceLine" id="cb5-6" data-line-number="6">        mst.add_weighted_edges_from([[parent, node[<span class="dv">0</span>], edge_weight]])</a></code></pre></div>
						<p>O código final para a função <code>prim</code> fica:</p>
						<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Prim. Recebe um nx.Graph e retorna um nx.DiGraph</span></a>
						<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">def</span> prim(graph):</a>
						<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="co"># Inicializa as cores dos vértices como branco</span></a>
						<a class="sourceLine" id="cb6-4" data-line-number="4">    nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
						<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="co"># Inicializa o pi(pai) dos vértices como None</span></a>
						<a class="sourceLine" id="cb6-7" data-line-number="7">    nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
						<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="co"># Inicializa o lambda(distância mínima) dos vértices como infinito</span></a>
						<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="co"># O vértice inicial recebe 0</span></a>
						<a class="sourceLine" id="cb6-11" data-line-number="11">    nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-12" data-line-number="12">    <span class="cf">for</span> node <span class="kw">in</span> graph.nodes:</a>
						<a class="sourceLine" id="cb6-13" data-line-number="13">        nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-14" data-line-number="14">        <span class="cf">break</span>   <span class="co"># Executa o loop para apenas um nó</span></a>
						<a class="sourceLine" id="cb6-15" data-line-number="15"></a>
						<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="co"># Enquanto existir um vértice não visitado, continua visitando</span></a>
						<a class="sourceLine" id="cb6-17" data-line-number="17">    nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>) <span class="co"># nos dá todos os vértices do grafo, junto com seus atributos</span></a>
						<a class="sourceLine" id="cb6-18" data-line-number="18">    <span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
						<a class="sourceLine" id="cb6-19" data-line-number="19">        <span class="co"># Seleciona apenas os vértices brancos</span></a>
						<a class="sourceLine" id="cb6-20" data-line-number="20">        white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
						<a class="sourceLine" id="cb6-21" data-line-number="21">        <span class="co"># Seleciona o vértice com menor lambda</span></a>
						<a class="sourceLine" id="cb6-22" data-line-number="22">        min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>])</a>
						<a class="sourceLine" id="cb6-23" data-line-number="23"></a>
						<a class="sourceLine" id="cb6-24" data-line-number="24">        <span class="co"># Itera sobre todos os vizinhos do vértice, e atualiza os atributos se necessário</span></a>
						<a class="sourceLine" id="cb6-25" data-line-number="25">        <span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
						<a class="sourceLine" id="cb6-26" data-line-number="26">            node_info <span class="op">=</span> (node, <span class="bu">dict</span>(nodes_info)[node])</a>
						<a class="sourceLine" id="cb6-27" data-line-number="27">            <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb6-28" data-line-number="28">                new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>]</a>
						<a class="sourceLine" id="cb6-29" data-line-number="29">                <span class="co"># Checa se é necessário atualizar os atributos</span></a>
						<a class="sourceLine" id="cb6-30" data-line-number="30">                <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
						<a class="sourceLine" id="cb6-31" data-line-number="31">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-32" data-line-number="32">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
						<a class="sourceLine" id="cb6-34" data-line-number="34">        nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb6-35" data-line-number="35">        nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
						<a class="sourceLine" id="cb6-36" data-line-number="36"></a>
						<a class="sourceLine" id="cb6-37" data-line-number="37">    <span class="co"># Digrafo resultante</span></a>
						<a class="sourceLine" id="cb6-38" data-line-number="38">    mst <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb6-39" data-line-number="39"></a>
						<a class="sourceLine" id="cb6-40" data-line-number="40">    <span class="co"># Adiciona os nós à mst</span></a>
						<a class="sourceLine" id="cb6-41" data-line-number="41">    <span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
						<a class="sourceLine" id="cb6-42" data-line-number="42">        <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
						<a class="sourceLine" id="cb6-43" data-line-number="43">            edge_weight <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
						<a class="sourceLine" id="cb6-44" data-line-number="44">            parent <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
						<a class="sourceLine" id="cb6-45" data-line-number="45">            mst.add_weighted_edges_from([[parent, node[<span class="dv">0</span>], edge_weight]])</a>
						<a class="sourceLine" id="cb6-46" data-line-number="46"></a>
						<a class="sourceLine" id="cb6-47" data-line-number="47">    <span class="cf">return</span> mst</a></code></pre></div>
						<p>O resultado da aplicação desse algoritmo, para esse <a href="pages/data/ha30_dist.txt">conjunto de dados</a>, pode ser visto na imagem a seguir:</p>

						<img src="pages/img/prim.jpeg" alt="Resultado da aplicação de Prim" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

                        <hr>

                        <!-- BFS and DFS -->
                        <h1 id="bfsdfs" class="section-heading">BFS e DFS</h1>
						<p>Para o terceiro trabalho, implementamos os algoritmos de DFS e BFS a seguir na linguagem Python:</p>
						<h3 id="dfs">DFS</h3>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1">DFS(G, s){</a>
						<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="op">//</span> Inicialização dos vértices</a>
						<a class="sourceLine" id="cb1-3" data-line-number="3">    para cada u ∈ V{</a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    u.cor <span class="op">=</span> BRANCO</a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    predecessor(u) <span class="op">=</span> nil</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6">    }</a>
						<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
						<a class="sourceLine" id="cb1-8" data-line-number="8">    tempo <span class="op">=</span> <span class="dv">0</span> <span class="op">//</span> variável <span class="kw">global</span> para armazenar o tempo</a>
						<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
						<a class="sourceLine" id="cb1-10" data-line-number="10">    DFS_visit(G, s)</a>
						<a class="sourceLine" id="cb1-11" data-line-number="11">}</a>
						<a class="sourceLine" id="cb1-12" data-line-number="12"></a>
						<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="co"># Função recursiva que é chamada sempre que um vértice é descoberto</span></a>
						<a class="sourceLine" id="cb1-14" data-line-number="14">DFS_visit(G, u){</a>
						<a class="sourceLine" id="cb1-15" data-line-number="15">     tempo<span class="op">++</span></a>
						<a class="sourceLine" id="cb1-16" data-line-number="16">     u.tempo_descoberto <span class="op">=</span> tempo</a>
						<a class="sourceLine" id="cb1-17" data-line-number="17">     u.cor <span class="op">=</span> CINZA</a>
						<a class="sourceLine" id="cb1-18" data-line-number="18">     <span class="op">//</span> Checa todos os vizinhos de u</a>
						<a class="sourceLine" id="cb1-19" data-line-number="19">     para cada v ∈ N(u){</a>
						<a class="sourceLine" id="cb1-20" data-line-number="20">    <span class="cf">if</span> v.color <span class="op">==</span> BRANCO{ <span class="op">//</span> Se existe um vizinho ainda não visitado, visite</a>
						<a class="sourceLine" id="cb1-21" data-line-number="21">        predecessor(v) <span class="op">=</span> u</a>
						<a class="sourceLine" id="cb1-22" data-line-number="22">        DFS_visit(G, v) <span class="op">//</span> chamada recursiva</a>
						<a class="sourceLine" id="cb1-23" data-line-number="23">    }</a>
						<a class="sourceLine" id="cb1-24" data-line-number="24">     }</a>
						<a class="sourceLine" id="cb1-25" data-line-number="25">     u.cor <span class="op">=</span> PRETO</a>
						<a class="sourceLine" id="cb1-26" data-line-number="26">     tempo<span class="op">++</span></a>
						<a class="sourceLine" id="cb1-27" data-line-number="27">     u.finalizado <span class="op">=</span> tempo</a>
						<a class="sourceLine" id="cb1-28" data-line-number="28">}</a></code></pre></div>
						<h3 id="bfs">BFS</h3>
						<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1">BFS(G, s){</a>
						<a class="sourceLine" id="cb2-2" data-line-number="2">     <span class="op">//</span> Inicialização dos vértices</a>
						<a class="sourceLine" id="cb2-3" data-line-number="3">     para todo v ∈ V − {s} {</a>
						<a class="sourceLine" id="cb2-4" data-line-number="4">      v.cor <span class="op">=</span> BRANCO</a>
						<a class="sourceLine" id="cb2-5" data-line-number="5">      distancia_minima(v) <span class="op">=</span> infinito</a>
						<a class="sourceLine" id="cb2-6" data-line-number="6">      predecessor(v) <span class="op">=</span> nil</a>
						<a class="sourceLine" id="cb2-7" data-line-number="7">     }</a>
						<a class="sourceLine" id="cb2-8" data-line-number="8">     <span class="op">//</span> Inicialização do vértice inicial</a>
						<a class="sourceLine" id="cb2-9" data-line-number="9">     s.cor <span class="op">=</span> CINZA</a>
						<a class="sourceLine" id="cb2-10" data-line-number="10">     distancia_minima(s)<span class="op">=</span><span class="dv">0</span></a>
						<a class="sourceLine" id="cb2-11" data-line-number="11">     predecessor(v) <span class="op">=</span> nil</a>
						<a class="sourceLine" id="cb2-12" data-line-number="12">     <span class="op">//</span> Inicialização da Fila</a>
						<a class="sourceLine" id="cb2-13" data-line-number="13">     Q <span class="op">=</span> []</a>
						<a class="sourceLine" id="cb2-14" data-line-number="14">     insere(Q, s)</a>
						<a class="sourceLine" id="cb2-15" data-line-number="15">     enquanto Q <span class="op">!=</span> vazia{</a>
						<a class="sourceLine" id="cb2-16" data-line-number="16">      u <span class="op">=</span> pop(Q)</a>
						<a class="sourceLine" id="cb2-17" data-line-number="17">      <span class="op">//</span> para todo vizinho de u</a>
						<a class="sourceLine" id="cb2-18" data-line-number="18">      <span class="cf">for</span> each v ∈ N (u){ </a>
						<a class="sourceLine" id="cb2-19" data-line-number="19">        <span class="op">//</span> se ainda não passei por aqui, processo vértice v</a>
						<a class="sourceLine" id="cb2-20" data-line-number="20">            <span class="cf">if</span> v.color <span class="op">==</span> BRANCO{</a>
						<a class="sourceLine" id="cb2-21" data-line-number="21">            <span class="op">//</span> v é descendente de u então distancia <span class="op">+</span> <span class="dv">1</span></a>
						<a class="sourceLine" id="cb2-22" data-line-number="22">            distancia_minima(v) <span class="op">=</span> distancia_minima(u) <span class="op">+</span> <span class="dv">1</span></a>
						<a class="sourceLine" id="cb2-23" data-line-number="23">            predecessor(v) <span class="op">=</span> u</a>
						<a class="sourceLine" id="cb2-24" data-line-number="24">            v.cor <span class="op">=</span> CINZA</a>
						<a class="sourceLine" id="cb2-25" data-line-number="25">            insere(Q, v)  <span class="op">//</span> adiciona v no final da fila</a>
						<a class="sourceLine" id="cb2-26" data-line-number="26">        }</a>
						<a class="sourceLine" id="cb2-27" data-line-number="27">       }</a>
						<a class="sourceLine" id="cb2-28" data-line-number="28">       u.cor <span class="op">=</span> PRETO <span class="op">//</span> Após explorar todos vizinhos de u, finalizo u</a>
						<a class="sourceLine" id="cb2-29" data-line-number="29">     }</a>
						<a class="sourceLine" id="cb2-30" data-line-number="30">}</a></code></pre></div>
						<p>E então os aplicamos nos grafos Dolphin’s Social Network e Zachary’s Karate Club:</p>
						<h3 id="resultados">Resultados</h3>
						<h4 id="karate">Karate:</h4>
						<h5 id="karatebfs">BFS:</h4>
						<img src="pages/img/bfs1.jpeg" alt="Resultado da aplicação de BFS" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

						<hr>
						<h5 id="karatedfs">DFS:</h5>
						<img src="pages/img/dfs1.jpeg" alt="Resultado da aplicação de DFS" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">							

						<h4 id="dolphins">Dolphins:</h4>
						<h5 id="dolphinsbfs">DFS:</h5>
						<img src="pages/img/bfs2.jpeg" alt="Resultado da aplicação de BFS" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

						<hr>
						<h5 id="dolphinsdfs">DFS:</h5>
						<img src="pages/img/dfs2.jpeg" alt="Resultado da aplicação de DFS" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">		
                        
                        <hr>

                        <!-- Dijkstra -->
                        <h1 id="dijkstra" class="section-heading">Algoritmo de Dijkstra</h1>
						<p>Encontrar caminhos mínimos utilizando grafos é um problema muito comum no nosso dia-a-dia. Os aplicativos que trabalham com mapas e rotas, na maior parte das vezes, tem que encontrar caminhos mínimos entre dois lugares. Para isso, é possível utilizar o algoritmo de Dijkstra, que nos permite buscar uma árvore de caminhos mínimos em um grafo, partindo de um ponto. Existe também a possibilidade de iniciarmos a busca de caminhos mínimos por mais de um ponto, para diversificar a geração de caminhos.</p>
						<p>Iremos então, implementar o algoritmo de Dijkstra multi-origens. Para isso, inicialmente criamos uma função chamada <code>dijkstra</code>, que recebe um <em>grafo</em> do tipo <code>networkx.Graph</code>, assim com um valor <em>sources</em>, que determina a quantidade de origens para o algoritmo.</p>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Dijkstra.</span></a>
						<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">def</span> dijkstra(graph, sources):</a>
						<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="co"># Árvore resultante</span></a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    tree <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="cf">return</span> tree</a></code></pre></div>
						<p>Em seguida, seguiremos a mesma lógica do algoritmo de Prim, alterando apenas a inicialização dos vértices origem. Portanto, cada vértice tem atributos <em>cor</em>, <em>lambda</em> e <em>pi</em>, elas significando respectivamente, se o vértice foi o visitado, a distância mínima total para aquele vértice encontrado e o pai daquele vértice. Temos então a inicialização dos mesmos:</p>
						<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># Inicializa a cor dos vértices (white: não visitado, black: visitado)</span></a>
						<a class="sourceLine" id="cb2-2" data-line-number="2">nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co"># Inicializa a lambda (distância mínima total dos vértices) como infinito</span></a>
						<a class="sourceLine" id="cb2-4" data-line-number="4">nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co"># Seleciona &#39;n&#39; elementos para iniciar o algoritmo (minimum distance = 0)</span></a>
						<a class="sourceLine" id="cb2-6" data-line-number="6">nodes <span class="op">=</span> random.sample(graph.nodes, sources)</a>
						<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="cf">for</span> node <span class="kw">in</span> nodes:</a>
						<a class="sourceLine" id="cb2-8" data-line-number="8">    nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="co"># Inicializa os o pai dos vértices como None</span></a>
						<a class="sourceLine" id="cb2-10" data-line-number="10">nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a></code></pre></div>
						<p>Logo depois, selecionamos todos os vértices e suas informações. Utilizando esses dados, criamos o loop principal, que executa enquanto existirem nós não visitados. Dentro desse loop, é necessário escolher qual será o próximo nó a ser visitado. Isso é determinado pelo menor valor de lambda, de um vértice não visitado.</p>
						<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Enquanto existir um vértice não visitado, continua executando o algortimo</span></a>
						<a class="sourceLine" id="cb3-2" data-line-number="2">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
						<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
						<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="co"># Seleciona os nós brancos, e em seguida, seleciona o nó com menor lambda que ainda não foi visitado</span></a>
						<a class="sourceLine" id="cb3-5" data-line-number="5">    white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
						<a class="sourceLine" id="cb3-6" data-line-number="6">    min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]) </a></code></pre></div>
						<p>Assim que selecionamos o vértice a ser analisado, iteramos sobre todos os seus vizinhos, checando se é necessário atualizar os valores de lambda e pi. Esse processo é semelhante ao algoritmo de Prim, a única diferença é que lambda nesse caso não é somente o valor da aresta, e sim a distância total do caminho. Portanto, temos:</p>
						<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># Itera sobre todos os vizinhos nó vértice selecionado.</span></a>
						<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
						<a class="sourceLine" id="cb4-3" data-line-number="3">    node_info <span class="op">=</span> (node, nodes_info[node])</a>
						<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb4-5" data-line-number="5">        new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>] <span class="op">+</span> min_node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
						<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="co"># Checa se é necessário atualizar os valores lambda e pi</span></a>
						<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
						<a class="sourceLine" id="cb4-8" data-line-number="8">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb4-9" data-line-number="9">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb4-10" data-line-number="10">nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb4-11" data-line-number="11">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
						<p>Só nos então, montar a árvore resultante da aplicação do algoritmo. Iteramos sobre cada grafo, adicionado-os com a informação de pi, como vértice pai e o peso da aresta entre o pai e o vértice, como o peso da aresta na árvore.</p>
						<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># Itera sobre todos os vértices, adicionado-os a árvore resultante</span></a>
						<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
						<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="op">!=</span> <span class="va">None</span>:</a>
						<a class="sourceLine" id="cb5-4" data-line-number="4">        edge_weight <span class="op">=</span> graph.get_edge_data(node[<span class="dv">0</span>], node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>])</a>
						<a class="sourceLine" id="cb5-5" data-line-number="5">        ancestor <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
						<a class="sourceLine" id="cb5-6" data-line-number="6">        tree.add_weighted_edges_from([[ancestor, node[<span class="dv">0</span>], edge_weight]])</a></code></pre></div>
						<p>O algoritmo finalizado é:</p>
						<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Dijkstra.</span></a>
						<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">def</span> dijkstra(graph, sources):</a>
						<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="co"># Inicializa a cor dos vértices (white: não visitado, black: visitado)</span></a>
						<a class="sourceLine" id="cb6-4" data-line-number="4">    nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="co"># Inicializa a lambda (distância mínima total dos vértices) como infinito</span></a>
						<a class="sourceLine" id="cb6-6" data-line-number="6">    nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="co"># Seleciona &#39;n&#39; elementos para iniciar o algoritmo (minimum distance = 0)</span></a>
						<a class="sourceLine" id="cb6-8" data-line-number="8">    nodes <span class="op">=</span> random.sample(graph.nodes, sources)</a>
						<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="cf">for</span> node <span class="kw">in</span> nodes:</a>
						<a class="sourceLine" id="cb6-10" data-line-number="10">        nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="co"># Inicializa os o pai dos vértices como None</span></a>
						<a class="sourceLine" id="cb6-12" data-line-number="12">    nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb6-13" data-line-number="13"></a>
						<a class="sourceLine" id="cb6-14" data-line-number="14">    <span class="co"># Enquanto existir um vértice não visitado, continua executando o algortimo</span></a>
						<a class="sourceLine" id="cb6-15" data-line-number="15">    nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
						<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
						<a class="sourceLine" id="cb6-17" data-line-number="17">        <span class="co"># Seleciona os nós brancos, e em seguida, seleciona o nó com menor lambda que ainda não foi visitado</span></a>
						<a class="sourceLine" id="cb6-18" data-line-number="18">        white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
						<a class="sourceLine" id="cb6-19" data-line-number="19">        min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]) </a>
						<a class="sourceLine" id="cb6-20" data-line-number="20"></a>
						<a class="sourceLine" id="cb6-21" data-line-number="21">        <span class="co"># Itera sobre todos os vizinhos nó vértice selecionado.</span></a>
						<a class="sourceLine" id="cb6-22" data-line-number="22">        <span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
						<a class="sourceLine" id="cb6-23" data-line-number="23">            node_info <span class="op">=</span> (node, nodes_info[node])</a>
						<a class="sourceLine" id="cb6-24" data-line-number="24">            <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb6-25" data-line-number="25">                new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>] <span class="op">+</span> min_node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
						<a class="sourceLine" id="cb6-26" data-line-number="26">                <span class="co"># Checa se é necessário atualizar os valores lambda e pi</span></a>
						<a class="sourceLine" id="cb6-27" data-line-number="27">                <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
						<a class="sourceLine" id="cb6-28" data-line-number="28">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-29" data-line-number="29">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb6-30" data-line-number="30">        nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb6-31" data-line-number="31">        nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
						<a class="sourceLine" id="cb6-32" data-line-number="32"></a>
						<a class="sourceLine" id="cb6-33" data-line-number="33">    <span class="co"># Árvore resultante</span></a>
						<a class="sourceLine" id="cb6-34" data-line-number="34">    tree <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb6-35" data-line-number="35"></a>
						<a class="sourceLine" id="cb6-36" data-line-number="36">    <span class="co"># Itera sobre todos os vértices, adicionado-os a árvore resultante</span></a>
						<a class="sourceLine" id="cb6-37" data-line-number="37">    <span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
						<a class="sourceLine" id="cb6-38" data-line-number="38">        <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="op">!=</span> <span class="va">None</span>:</a>
						<a class="sourceLine" id="cb6-39" data-line-number="39">            edge_weight <span class="op">=</span> graph.get_edge_data(node[<span class="dv">0</span>], node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>])</a>
						<a class="sourceLine" id="cb6-40" data-line-number="40">            ancestor <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
						<a class="sourceLine" id="cb6-41" data-line-number="41">            tree.add_weighted_edges_from([[ancestor, node[<span class="dv">0</span>], edge_weight]])</a>
						<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
						<a class="sourceLine" id="cb6-43" data-line-number="43">    <span class="cf">return</span> tree</a></code></pre></div>
						<p>O resultado da aplicação desse algoritmo para o <a href="pages/data/wg59_dist.txt">conjunto de dados</a>, pode ser visto na imagem a seguir (primeira imagem tem source=2, e a segunda tem source=3):</p>
						            

						<img src="pages/img/dijkstra2.jpeg" alt="Resultado da aplicação de Dijkstra com duas origens" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">
						<hr>

						<img src="pages/img/dijkstra3.jpeg" alt="Resultado da aplicação de Dijkstra com três origens" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

                        <hr>

						<!-- TSP -->
                        <h1 id="tsp" class="section-heading">Problema do Caixeiro Viajante</h1>
						<p>Para este problema, implementamos o algoritmo Twice Around em Python:</p>
						<h3 id="twice-around">Twice Around</h3>
						<p>Ler grafo G = (V, E, p) H ← vazia</p>
						<ul>
						<li>Passo 1.:
							<ul>
								<li>T ← MST(G) // Aplicando o algoritmo de Kruskal</li>
								<li>Para cada e ∈ T, T ← T + e (Duplique aresta e)</li>
							</ul>
						</li>
						<li>Passo 2. Encontre um circuito Euleriano L em T // Aplicando Fleury</li>
						<li>Passo 3. 
							<ul>
								<li>Enquanto L != vazio:</li>
								<li>Escolha sequencialmente lk ∈ L</li>
								<li>Se lk ∉ H então:</li>
								<li>H ← H U {lk}</li>
								<li>L ← L – {lk}</li>
							</ul>
						</li>
						</ul>
						<h3 id="código">Código</h3>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">def</span> twicearound(graph, source<span class="op">=</span><span class="dv">0</span>):</a>
						<a class="sourceLine" id="cb1-2" data-line-number="2">    mst <span class="op">=</span> nx.minimum_spanning_tree(graph) <span class="co"># Gerando a mst a partir do grafo original</span></a>
						<a class="sourceLine" id="cb1-3" data-line-number="3">    mst_multi <span class="op">=</span> nx.MultiGraph(mst) <span class="co"># Apenas Multigraphs aceitam arestas paralelas</span></a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    </a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    multi_copy <span class="op">=</span> mst_multi.copy()</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="cf">for</span> u,v <span class="kw">in</span> multi_copy.edges():</a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">        mst_multi.add_edge(u,v)     <span class="co">#Duplicando as arestas da mst</span></a>
						<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
						<a class="sourceLine" id="cb1-9" data-line-number="9">    euler <span class="op">=</span> <span class="bu">list</span>(nx.eulerian_circuit(mst_multi, source)) <span class="co"># Gerando um circuito euleriano</span></a>
						<a class="sourceLine" id="cb1-10" data-line-number="10">    cycle <span class="op">=</span> nx.Graph()</a>
						<a class="sourceLine" id="cb1-11" data-line-number="11">    aux <span class="op">=</span> []</a>
						<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="cf">for</span> u,v <span class="kw">in</span> euler: </a>
						<a class="sourceLine" id="cb1-13" data-line-number="13">        aux.append(u)</a>
						<a class="sourceLine" id="cb1-14" data-line-number="14">        aux.append(v)</a>
						<a class="sourceLine" id="cb1-15" data-line-number="15">    h <span class="op">=</span> []</a>
						<a class="sourceLine" id="cb1-16" data-line-number="16">    <span class="cf">for</span> i <span class="kw">in</span> aux: </a>
						<a class="sourceLine" id="cb1-17" data-line-number="17">        <span class="cf">if</span> (i <span class="kw">not</span> <span class="kw">in</span> h):    <span class="co"># Eliminando repetições</span></a>
						<a class="sourceLine" id="cb1-18" data-line-number="18">            h.append(i)</a>
						<a class="sourceLine" id="cb1-19" data-line-number="19">    h.append(source)</a>
						<a class="sourceLine" id="cb1-20" data-line-number="20">    f_weight <span class="op">=</span> <span class="dv">0</span></a>
						<a class="sourceLine" id="cb1-21" data-line-number="21">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">30</span>):</a>
						<a class="sourceLine" id="cb1-22" data-line-number="22">        cycle.add_edge(h[i],h[i<span class="op">+</span><span class="dv">1</span>]) <span class="co"># Gerando grafo resultante</span></a>
						<a class="sourceLine" id="cb1-23" data-line-number="23">        cycle[h[i]][h[i<span class="op">+</span><span class="dv">1</span>]][<span class="st">&#39;weight&#39;</span>] <span class="op">=</span> graph[h[i]][h[i<span class="op">+</span><span class="dv">1</span>]][<span class="st">&#39;weight&#39;</span>] <span class="co"># copiando tambem o peso</span></a>
						<a class="sourceLine" id="cb1-24" data-line-number="24">        f_weight <span class="op">+=</span> graph[h[i]][h[i<span class="op">+</span><span class="dv">1</span>]][<span class="st">&#39;weight&#39;</span>]</a>
						<a class="sourceLine" id="cb1-25" data-line-number="25">    </a>
						<a class="sourceLine" id="cb1-26" data-line-number="26">    <span class="cf">return</span> (cycle, f_weight)</a></code></pre></div>
						<p>E então, iniciando o algoritmo sempre com vértices aleatórios rodamos ele 10 vezes para poder listar os melhores e piores 3 resultados obtidos.</p>
						<h2 id="resultados">Resultados:</h2>

						<img src="pages/img/tsp10results.jpeg" alt="Resultado da aplicação do algoritmo Twice-Around para dez ciclos diferentes" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

						<p>Como visto, existe uma discrepância notável entre o melhor(529.0) e o pior resultado(622.0), e isso se deve ao fato do Twice Around ser um algoritmo guloso, o que faz com que ele só avalie as melhores opções locais e não globais, podendo haver bastante diferença dependendo de onde é iniciado o algoritmo. Um bom jeito de amenizar essas discrepâncias é escolher um bom ponto inicial, por exemplo.</p>

						<hr>
                    </div>
                </div>
            </div>
        </article>
    <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
